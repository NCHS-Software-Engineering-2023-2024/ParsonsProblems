{"ast":null,"code":"var gridSize = 40;\nvar minWidth = 50;\nexport const snapGridModifier = ({\n  containerNodeRect,\n  draggingNodeRect,\n  transform\n}) => {\n  var xval = transform.x;\n  var yval = transform.y;\n  var xtransform = transform.scaleX;\n\n  //if you don't \"collide\" with the container then move along grid\n  //this never happens anyway.\n  if (!draggingNodeRect || !containerNodeRect) xval = Math.ceil(transform.x / gridSize) * gridSize;else {\n    var rect = draggingNodeRect;\n    var boundingRect = containerNodeRect;\n\n    //snap dragging block within top/bottom bounds\n    if (rect.top + transform.y <= boundingRect.top) {\n      yval = boundingRect.top - rect.top;\n    } else if (rect.bottom + transform.y >= boundingRect.top + boundingRect.height) {\n      yval = boundingRect.top + boundingRect.height - rect.bottom;\n    }\n\n    //snap dragging block within left bound\n    if (rect.left + transform.x <= boundingRect.left) {\n      xval = boundingRect.left - rect.left;\n    } else if (rect.right + transform.x >= boundingRect.left + boundingRect.width) {\n      // if the new rect.width doesn't subsceed the minWidth\n      // dont snap dragging block within right bound\n      // allow transform width + can move right.\n      if (rect.width - gridSize <= minWidth) {\n        xtransform = (rect.width - gridSize) / rect.width;\n        xval = Math.ceil(xval / gridSize) * gridSize;\n      } else {\n        //else snap dragging block within right bound\n        xval = boundingRect.left + boundingRect.width - rect.right;\n      }\n    }\n  }\n  return {\n    ...transform,\n    scaleX: xtransform,\n    x: xval,\n    y: yval\n  };\n};","map":{"version":3,"names":["gridSize","minWidth","snapGridModifier","containerNodeRect","draggingNodeRect","transform","xval","x","yval","y","xtransform","scaleX","Math","ceil","rect","boundingRect","top","bottom","height","left","right","width"],"sources":["C:/Users/ajbukowski/aryanp/parsons-problems/client/src/snapGridModifier.ts"],"sourcesContent":["import type {Modifier} from '@dnd-kit/core';\r\nimport type {ClientRect} from '@dnd-kit/core';\r\n\r\nvar gridSize = 40;\r\nvar minWidth = 50;\r\n\r\nexport const snapGridModifier: Modifier = ({\r\n    containerNodeRect,\r\n    draggingNodeRect,\r\n    transform,\r\n  }) => {\r\n    var xval = transform.x;\r\n    var yval = transform.y;\r\n    var xtransform = transform.scaleX;\r\n\r\n    //if you don't \"collide\" with the container then move along grid\r\n    //this never happens anyway.\r\n    if(!draggingNodeRect || !containerNodeRect)\r\n      xval = Math.ceil(transform.x / gridSize) * gridSize\r\n    else \r\n    {\r\n      var rect = draggingNodeRect;\r\n      var boundingRect = containerNodeRect;\r\n\r\n      //snap dragging block within top/bottom bounds\r\n      if (rect.top + transform.y <= boundingRect.top) {\r\n        yval = boundingRect.top - rect.top;\r\n      } else if (rect.bottom + transform.y >= boundingRect.top + boundingRect.height) {\r\n        yval = boundingRect.top + boundingRect.height - rect.bottom;\r\n      }\r\n\r\n      //snap dragging block within left bound\r\n      if (rect.left + transform.x <= boundingRect.left) {\r\n        xval = boundingRect.left - rect.left\r\n      } else if (rect.right + transform.x >= boundingRect.left + boundingRect.width)  {\r\n\r\n        // if the new rect.width doesn't subsceed the minWidth\r\n        // dont snap dragging block within right bound\r\n        // allow transform width + can move right.\r\n        if (rect.width - gridSize <= minWidth) { \r\n          xtransform = (rect.width - gridSize) / rect.width\r\n          xval = Math.ceil(xval / gridSize) * gridSize\r\n        } else { //else snap dragging block within right bound\r\n          xval = boundingRect.left + boundingRect.width - rect.right              \r\n        }\r\n      }\r\n    }\r\n\r\n    return({\r\n      ...transform,\r\n      scaleX: xtransform,\r\n      x: xval,\r\n      y: yval,\r\n    })\r\n};\r\n    "],"mappings":"AAGA,IAAIA,QAAQ,GAAG,EAAE;AACjB,IAAIC,QAAQ,GAAG,EAAE;AAEjB,OAAO,MAAMC,gBAA0B,GAAGA,CAAC;EACvCC,iBAAiB;EACjBC,gBAAgB;EAChBC;AACF,CAAC,KAAK;EACJ,IAAIC,IAAI,GAAGD,SAAS,CAACE,CAAC;EACtB,IAAIC,IAAI,GAAGH,SAAS,CAACI,CAAC;EACtB,IAAIC,UAAU,GAAGL,SAAS,CAACM,MAAM;;EAEjC;EACA;EACA,IAAG,CAACP,gBAAgB,IAAI,CAACD,iBAAiB,EACxCG,IAAI,GAAGM,IAAI,CAACC,IAAI,CAACR,SAAS,CAACE,CAAC,GAAGP,QAAQ,CAAC,GAAGA,QAAQ,MAErD;IACE,IAAIc,IAAI,GAAGV,gBAAgB;IAC3B,IAAIW,YAAY,GAAGZ,iBAAiB;;IAEpC;IACA,IAAIW,IAAI,CAACE,GAAG,GAAGX,SAAS,CAACI,CAAC,IAAIM,YAAY,CAACC,GAAG,EAAE;MAC9CR,IAAI,GAAGO,YAAY,CAACC,GAAG,GAAGF,IAAI,CAACE,GAAG;IACpC,CAAC,MAAM,IAAIF,IAAI,CAACG,MAAM,GAAGZ,SAAS,CAACI,CAAC,IAAIM,YAAY,CAACC,GAAG,GAAGD,YAAY,CAACG,MAAM,EAAE;MAC9EV,IAAI,GAAGO,YAAY,CAACC,GAAG,GAAGD,YAAY,CAACG,MAAM,GAAGJ,IAAI,CAACG,MAAM;IAC7D;;IAEA;IACA,IAAIH,IAAI,CAACK,IAAI,GAAGd,SAAS,CAACE,CAAC,IAAIQ,YAAY,CAACI,IAAI,EAAE;MAChDb,IAAI,GAAGS,YAAY,CAACI,IAAI,GAAGL,IAAI,CAACK,IAAI;IACtC,CAAC,MAAM,IAAIL,IAAI,CAACM,KAAK,GAAGf,SAAS,CAACE,CAAC,IAAIQ,YAAY,CAACI,IAAI,GAAGJ,YAAY,CAACM,KAAK,EAAG;MAE9E;MACA;MACA;MACA,IAAIP,IAAI,CAACO,KAAK,GAAGrB,QAAQ,IAAIC,QAAQ,EAAE;QACrCS,UAAU,GAAG,CAACI,IAAI,CAACO,KAAK,GAAGrB,QAAQ,IAAIc,IAAI,CAACO,KAAK;QACjDf,IAAI,GAAGM,IAAI,CAACC,IAAI,CAACP,IAAI,GAAGN,QAAQ,CAAC,GAAGA,QAAQ;MAC9C,CAAC,MAAM;QAAE;QACPM,IAAI,GAAGS,YAAY,CAACI,IAAI,GAAGJ,YAAY,CAACM,KAAK,GAAGP,IAAI,CAACM,KAAK;MAC5D;IACF;EACF;EAEA,OAAO;IACL,GAAGf,SAAS;IACZM,MAAM,EAAED,UAAU;IAClBH,CAAC,EAAED,IAAI;IACPG,CAAC,EAAED;EACL,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}